#!/bin/bash

# Parse Apache access logs to extract message view timestamps
# Usage: ./parse_access_logs.sh /path/to/access.log [output_file]
#
# This script extracts the FIRST view of each /s/{message_url} page
# and generates SQL UPDATE statements to backfill viewed_at timestamps.

LOG_FILE="${1:-access.log}"
OUTPUT_FILE="${2:-backfill_viewed_at.sql}"

if [ ! -f "$LOG_FILE" ]; then
    echo "Error: Log file not found: $LOG_FILE"
    echo "Usage: $0 /path/to/access.log [output_file.sql]"
    exit 1
fi

echo "Parsing: $LOG_FILE"
echo "Output: $OUTPUT_FILE"
echo ""

# Create SQL file with header
cat > "$OUTPUT_FILE" << 'HEADER'
-- Backfill viewed_at timestamps from Apache access logs
-- Generated by parse_access_logs.sh
-- Only updates messages where viewed_at IS NULL

BEGIN TRANSACTION;

HEADER

# Parse logs and extract first view of each message URL
# Apache Combined Log Format: IP - - [timestamp] "METHOD /path HTTP/x.x" status size "referer" "user-agent"
#
# We filter for:
# - GET requests to /s/{message_url}
# - HTTP 200 responses only
# - Exclude bots (basic filter)

grep -E 'GET /s/[a-zA-Z0-9]+ HTTP' "$LOG_FILE" | \
grep -v -i 'bot\|crawler\|spider\|curl\|wget' | \
grep ' 200 ' | \
awk '
{
    # Extract timestamp: [10/Feb/2026:14:30:45 -0800]
    match($0, /\[([0-9]+)\/([A-Za-z]+)\/([0-9]+):([0-9:]+)/, ts)

    # Extract message URL
    match($0, /GET \/s\/([a-zA-Z0-9]+)/, url)

    if (url[1] && ts[1]) {
        message_url = url[1]

        # Convert month name to number
        months["Jan"]="01"; months["Feb"]="02"; months["Mar"]="03"
        months["Apr"]="04"; months["May"]="05"; months["Jun"]="06"
        months["Jul"]="07"; months["Aug"]="08"; months["Sep"]="09"
        months["Oct"]="10"; months["Nov"]="11"; months["Dec"]="12"

        month_num = months[ts[2]]

        # Format: YYYY-MM-DD HH:MM:SS
        timestamp = ts[3] "-" month_num "-" ts[1] " " ts[4]

        # Only keep first occurrence of each message_url
        if (!(message_url in first_view)) {
            first_view[message_url] = timestamp
        }
    }
}
END {
    for (url in first_view) {
        printf "UPDATE messages SET viewed_at = '\''%s'\'' WHERE message_url = '\''%s'\'' AND viewed_at IS NULL;\n", first_view[url], url
    }
}
' >> "$OUTPUT_FILE"

# Add footer
cat >> "$OUTPUT_FILE" << 'FOOTER'

COMMIT;

-- Summary: Run this to see how many rows would be updated
-- SELECT COUNT(*) FROM messages WHERE viewed_at IS NULL AND message_url IN (
--   SELECT message_url FROM messages WHERE smiled_at IS NULL
-- );
FOOTER

# Count results
UPDATES=$(grep -c "^UPDATE" "$OUTPUT_FILE")
echo "Found $UPDATES unique message views to backfill"
echo ""
echo "Review the SQL file, then run:"
echo "  sqlite3 database/happiness.db < $OUTPUT_FILE"
